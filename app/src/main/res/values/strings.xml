<resources>
    <string name="app_name">Android App Example</string>
    <string name="navigation_drawer_open">Open navigation drawer</string>
    <string name="navigation_drawer_close">Close navigation drawer</string>
    <string name="nav_header_title">IG3 - Mobile Development</string>
    <string name="nav_header_subtitle" translatable="false">Anne SMAL &amp; Lisa TRAPLETTI</string>
    <string name="nav_header_desc">Navigation header</string>
    <string name="action_settings">Settings</string>

    <string name="refresh">Refresh</string>

    <string name="menu_module_1">1. Activity &amp; Fragments</string>
    <string name="menu_module_2">2. Resources</string>
    <string name="menu_module_3">3. Architecture</string>
    <string name="menu_module_4">4. Persistence</string>
    <string name="menu_module_5">5. Async &amp; API</string>
    <string name="menu_module_6">6. Kotlin</string>

    <string name="module_title_start">Start</string>

    <string name="title_activity_welcome">AppExample</string>

    <string name="welcome_title">Welcome !</string>
    <string name="welcome_description">Through this application, you will learn how to develop an Android mobile app.
        Use it as an example : Go to the source code, test it with some rotation, plane mode, …
        So that you will discover how to create your own super project. \n
        OK, time to dive into the amazing Android World !
    </string>

    <!-- Module 1 Activities and Fragments -->
    <string name="module_1_title">Activities &amp; Fragments</string>
    <string name="module_1_description">Activities and fragments are the basis of a mobile application,
        as they are representing your entire User Interface. \n
        In this chapter, you will learn what is an activity, a fragment, and how Android OS is working
        with them.
    </string>

    <string name="module_1_activity_lifecycle_title">Activity lifecycle</string>

    <string name="module_1_what_is_an_activity_title">What is an Activity ?</string>
    <string name="module_1_what_is_an_activity_description">An <b>activity</b> provides the window
        in which the app draws its UI. Generally, one activity implements one screen of the app. \n \n

        <b><u>How to create an activity ?</u></b> \n
        For this, we need : \n
        - A Java (or Kotlin) class extending Activity; \n
        - A layout; \n
        - To declare it in the app\'s manifest (AndroidManifest.xml); \n \n

        The <b>Java class</b> represents the <b>layout</b> part of an activity. \n
        The <b><u>How to navigate through activities ?</u></b> represents its view part, written in XML. You will have more details about
        layouts in the next chapter. \n \n \n

        <b>intent</b> \n
        By using an <b>Explicit intent</b>. An Intent describes an action to perform. You can either : \n
        - Start an Activity (within your own app, or another app); \n
        - Start a Service (background / foreground worker); \n
        - Deliver a broadcast (delivered to all the apps); \n \n

        There are two types of them : \n
        - <b>Implicit intent</b> : The target app is specified; \n
        - <i>business</i> : A general action is specified (Take a picture, …) \n \n

        Go to the <i>WelcomeActivity</i> to discover how to create an explicit intent. \n
        For the implicit intent, click on the next button and go to the code to check the differences between
        the two intents.
    </string>

    <string name="module_1_how_to_use_activities">When you send an Intent, if Android sees more
        than one app that can handle it, it will show a Chooser. Android knows which app can handle
        which actions by checking their Manifest. \n
        That\'s why in our example, we had to write in the manifest that we are using the camera. \n
        Go to the manifest to check.
    </string>

    <string name="module_1_go_to_camera">Use camera</string>


    <string name="module_1_every_activity_has_its_lifecycle">An activity has its own lifecycle : </string>
    <string name="module_1_go_to_lifecycle_testing_activity"> <b>NEVER</b> call these methods yourself :
        This lifecycle is managed only by Android. \n \n
        Understanding the lifecycle of an activity, and what you can / should do at each step is very
        important part of the mobile development. \n
        Go to the <b>LifecycleTestingActivity</b> and discover how this lifecycle is working and how
        Android is managing it.</string>
    <string name="module_1_test_lifecycle">Test lifecycle</string>

    <string name="title_activity_lifecycle_testing">LifecycleTestingActivity</string>
    <string name="module_1_lifecycle_testing_description">
        Mastering the lifecycle of an activity will considerably help you to avoid a lot of bugs.
        So take your time to analyze the logs, the code, play with the emulator, …
        And ask you the following questions : What would happen if \n

        - I\'m initializing my counter in onStart() instead of onCreate() ? \n
        - I\'m leaving the application ? \n
        - I\'m rotating the phone ? \n
        - Android is killing my app to free some resources for other apps ? (Yes, … it does) \n
    </string>
    <string name="my_counter">My counter : %1$d</string>


    <string name="module_1_what_is_a_fragment_title">What is a fragment ?</string>
    <string name="module_1_what_is_a_fragment_description"> As you saw, we didn\'t create an activity
        for each screen of our app. It is because we decided to use <b>fragments</b>, combined to
        our activities. \n \n
        A <b>fragment</b> is a piece of user interface, used in an activity.
        Fragments have been introduced by Android for app development on bigger devices (such as tablets) :
        As a fragment is only a "piece" of UI, you can combine multiple fragments in a single activity
        to build a multi-pane UI and reuse a fragment in different activities. \n
    </string>
    <string name="module_1_fragment_lifecycle">Fragments also have their own lifecycle, which is very
        similar to activity lifecycle, but has some particularities. Go to the <b>LifecycleTestingFragment</b>
        to check the differences with the activity lifecycle.</string>

    <string name="module_1_fragments_on_smartphone">On smartphone</string>
    <string name="module_1_fragments_on_tablet">On tablet</string>

    <string name="module_1_multipane_fragment">You can think of a fragment as a modular section of an activity,
        which has its own lifecycle, receives its own input events, and which you can add or remove
        while the activity is running. \n \n
        Check <b>WhatIsAFragmentFragment</b> class and try to understand how an
        activity can integrate a fragment in its UI.
    </string>


    <string name="module_1_my_first_ui">My first UI</string>
    <string name="module_1_first_ui_name">Name</string>
    <string name="module_1_first_ui_age">Age</string>
    <string name="module_1_first_ui_mail">Mail</string>
    <string name="module_1_first_ui_password">Password</string>
    <string name="module_1_first_toast">Toast</string>
    <string name="module_1_toast_hello_message">Hello %1$s, this is a toast !</string>

    <string name="module_1_passing_arguments_description">It is possible to pass some
    information from a fragment to another, using <b>bundles</b>. Go to the <b>FirstUiFragment</b>
    and <b>SecondUiFragment</b> classes to check this mechanism.</string>

    <string name="module_1_mandatory_field">Mandatory field</string>
    <string name="module_1_first_ui_not_valid_age">Not valid age</string>
    <string name="module_1_first_ui_invalid_format">Invalid format</string>


    <!-- Module 2 Resources -->
    <string name="module_2_title">Resources</string>
    <string name="module_2_description">Layouts, images, colors, navigation, strings, … Resources
        are a very important part of the Android Development. In this module, you will learn
        what is the role of each resource type, and how to use them efficiently in your app.
    </string>

    <string name="module_2_resources_types_title">Resources Types</string>

    <string name="module_2_resources_organisation_by_android_studio">Additional files and <b>static
        content</b> that your code uses, such as bitmaps, layout definitions, ui strings, … \n
        You should always externalize app resources such as images and strings from your code,
        so that you can maintain them independently (In any case, Android Studio will warn you to do it). \n \n

        <b><u>Resources for specific cases</u></b> \n
        If you need alternative resources for specific <b>device configurations</b>, you can provide those
        by grouping them in specially-named resource directories, using <b>qualifiers</b>. At runtime,
        Android will use the appropriate resource based on the current phone configuration.
        (Try to rotate to check) \n \n

        Under the folder <b>res</b>, you can find the following hierarchy, that you need to respect :
    </string>

    <string name="module_2_resources_for_specific_cases">See ? The view is not the same anymore. \n
        There is a lot of different qualifiers : Orientation, language, screen size, country code, …
        Following your needs, you can combine them and create very specific resources. \n
    </string>

    <string name="module_2_resource_type_drawable" translatable="false">Drawable</string>
    <string name="module_2_resource_type_layout" translatable="false">Layout</string>
    <string name="module_2_resource_type_menu" translatable="false">Menu</string>
    <string name="module_2_resource_type_mipmap" translatable="false">Mipmap</string>
    <string name="module_2_resource_type_navigation" translatable="false">Navigation</string>
    <string name="module_2_resource_type_values" translatable="false">Values</string>

    <!-- Module 3 : Drawables & MipMap -->
    <string name="module_2_drawables_what_is_it">Drawables are <b>things that can be drawn</b>. Typically,
        they can be used as images, backgrounds, … \n
        Drawables can be : \n
        - Raw types (JPG, PNG, …); \n
        - Vector (XML, SVG, …); \n \n

        <b><u>What about mipmaps ?</u></b> \n
        Mipmap are drawable files used for different <b>launcher icon densities</b>. Mipmap will then, just contain
        your app icons, while drawables will contain all the rest. \n \n

        <b><u>Pre-scaling</u></b> \n
        When using a bitmap, try to pre-scale them when it is possible. You can do that online or with
        a plugin integrated to Android Studio. Automatically, Android will choose the right size of image
        following the device configurations, to avoid blurry images. \n \n
    </string>

    <string name="module_2_drawables_references">To create your drawables, you can use following links : \n
        <u>https://material.io/resources/icons/?style=baseline</u> \n
        <u>https://www.pexels.com</u> \n
    </string>

    <string name="module_2_glide">Glide</string>
    <string name="module_2_what_is_glide"><b>Glide</b> is an open source media management and image loading framework that will considerably
        help you to handle images during your development. It takes care of operations such as : \n
        - Crop, resize, …; \n
        - Download images from the web; \n
        - Caching; \n
        - Dynamic stuffs; \n \n

        Do not try to do this with Bitmaps, BitmapFactory, … to mange your images, it doesn\'t worth it.
        Use Glide. \n \n
        You can find the full documentation of the framework here : https://bumptech.github.io/glide/
        and on GitHub : https://github.com/bumptech/glide
    </string>


    <!-- Module 2 : Layouts -->
    <string name="module_2_layouts_what_is_it">The layout is a set of XML tags, that defines the
        structure for a user interface in your app that can either be linked to an activity, a fragment, …
        All elements in the layout are built using a hierarchy of View and ViewGroup objects. \n \n

        A <b>View</b> usually draws something the user can see and interact with (such as Button, TextView, …). \n
        A <b>ViewGroup</b> is an invisible container that defines the layout structure for View and other ViewGroup objects
        (LinearLayout, ConstraintLayout, …) \n \n

        The <b>root</b> of the layout is always a ViewGroup.
    </string>

    <string name="module_2_layouts_android_studio_palette">To create your layouts, Android Studio offers the possibilities to : \n
        - Use a visual editor, with drag-and-drop features; \n
        - To directly edit the XML code; \n \n \n

        <b><u>UI Elements Attributes</u></b> \n
        Each control (XML tag) has a set of attributes, like ID, color, width, height, text, constraints, …
        That you can edit through the XML file or the Java (or Kotlin) class referencing the layout. \n
        The ID you assign to a control is unique inside the current layout, and needed to be retrieved
        at Java side. \n \n

        <b><u>onSaveInstanceState</u></b> \n
        Remember this method ? Giving an ID to your control will help Android to save its current state,
        before the activity (or fragment) is destroyed for a reason or another. Write some value in the
        following EditText, and try to delete its ID to see what happens.
    </string>

    <string name="module_2_layouts_view_binding_what_is_it">After the layout is inflated, controls can
        be referenced from Java class using their ID and the method <b>findViewById()</b>. This is the
        classical method we used in every fragment until now. \n
        However, to avoid this redundancy, Android JetPack contains now a functionality called <b>View Binding</b> \n \n

        View Binding avoids us useless full of findViewById in our class, making it lighter and easier
        to maintain. You can use it either in activities or fragments.
    </string>
    <string name="module_2_layouts_view_binding_in_action">Just to show view binding in action</string>
    <string name="module_2_layout_structure_title">Layout Structure</string>
    <string name="module_2_layout_view_binding_title">View Binding</string>

    <!-- Module 2 : Navigation -->
    <string name="module_2_navigation_graph">A <b>navigation graph</b> is a XML resource, containing all
        the navigation interactions between fragments for an activity. Each activity will have its own
        navigation graph (if containing multiple UI). \n
        You can create your navigation graph using the Android Studio\'s visual tool. \n \n

        <b><u>NavigationHostFragment</u></b> \n
        Fragment of the Navigation library, provided by Android. This fragment acts like a host for each
        fragment of the navigation graph. \n
        As the user moves between destinations within the navigation graph, this host swaps the fragments
        in and out as necessary and automatically creates appropriate back stack. \n
        To see an example, go and check the <b>main_content.xml</b> layout and its corresponding
        class. \n \n

        <b><u>Arguments between fragments</u></b> \n
        Instead of creating a bundle to pass arguments between your fragments, you can use the provided
        navigation graph mechanism called <b>Safe Args</b>. \n
        Go to the class and the navigation graph to check how it\'s working.
    </string>
    <string name="module_2_navigation_getting_first_safe_arg">Hello ! This is your first Safe-Arg !</string>

    <!-- Module 2 : Menus -->
    <string name="module_2_menus_what_is_it">Menus are a common user interface component in many types of applications. \n \n
        For all menu types, Android provides a standard XML format to define menu items. Instead
        of building a menu in your activity\'s code, you should define a menu and all its items
        in an XML menu resource. You can then inflate the menu resource (load it as a Menu object)
        in your activity or fragment. \n \n
        Using a menu resource is a good practice for a few reasons: \n
        - It\'s easier to visualize the menu structure in XML; \n
        - It separates the content for the menu from your application\'s behavioral code; \n
        - It allows you to create alternative menu configurations for different platform versions,
        screen sizes, and other configurations by leveraging the app resources framework. \n \n

        <b><u>Menu Types</u></b> \n
        In Android, you can find different types of menus : \n
        - <u>Options menu and app bar</u> : Primary collection of menu items for an activity.
        It\'s where you should place actions that have a global impact on the app, such as "Search",
        "Compose email," and "Settings." \n
        - <u>Context menu and contextual action mode</u> : Floating menu that appears when the user
        performs a long-click on an element \n
        - <u>Popup menu</u> : Displays a list of items in a vertical list that\'s anchored to the
        view that invoked the menu. It\'s good for providing an overflow of actions that relate
        to specific content or to provide options for a second part of a command. \n
    </string>
    <string name="module_2_menu_try_this">Try this</string>
    <string name="module_2_menus_testing_menu">See ? Possible to make actions from menu</string>

    <!-- Module 2 : Values -->
    <string name="module_2_values_what_is_it">XML files that contain <b>simple values</b>, such as strings,
        integers, and colors. \n
        Whereas XML resource files in other res/ subdirectories define a single resource based on
        the XML filename, files in the values/ directory describe multiple resources. For a file in
        this directory, each child of the <b>resources</b> element defines a single resource. For example,
        a <b>string</b> element creates a R.string resource and a <b>color</b> element creates a
        R.color resource. \n \n

        <b><u>Alternative resources</u></b> \n
        Just like any other resources, you can provide alternative resources using qualifiers
        following device specifications (New language for strings, new dimensions for bigger screen
        sizes, …) \n \n

        <b><u>Values Types</u></b> \n
        Because each resource is defined with its own XML element, you can name the file whatever
        you want and place different resource types in one file. However, for clarity, we generally
        place unique resource types in different files, just like this : \n
        - arrays.xml for resource arrays (typed arrays); \n
        - colors.xml for color values; \n
        - dimens.xml for dimension values; \n
        - strings.xml for string values; \n
        - styles.xml for styles; \n \n

        For more resource types, go and check <u>https://developer.android.com/guide/topics/resources/more-resources</u>
    </string>

    <!-- Module 3 : App Architecture -->
    <string name="module_3_title">App Architecture</string>
    <string name="module_3_description">To maintain easily your app, it is recommended to write your
        code following an architecture. \n
        In this chapter, you will learn more about the default Android architecture called MVVM, and
        on its dedicated components called <b>View Models</b>.
    </string>
    <string name="module_3_what_is_view_model_title">ViewModel</string>
    <string name="module_3_data_binding_title">Data Binding &amp; ViewModels</string>
    <string name="module_3_view_model_pass_args_title">Passer des arguments</string>
    <string name="module_3_mvvm_architecture_title">Android MVVM Architecture</string>

    <string name="module_3_what_is_a_view_model">ViewModel is a component provided by Android
        in its official architecture pattern. This architecture is inspired from
        the MVVM (Model - View - ViewModel) architecture. \n
        A ViewModel is ALWAYS associated to
        an activity or a fragment and is initialized / living / destroyed with it.
    </string>
    <string name="module_3_architecture_derived_from_mvvm">
        <b><u>LiveData</u></b> \n
        The architecture proposed by Android is unidirectional, meaning that View can communicate with
        ViewModels, but ViewModels can not communicate with View. For this, we are using <b>LiveData</b>. \n
        LiveData mechanism is inspired of the <i>Observer</i> design pattern : The View (Fragment or Activity)
        will "listen" to the ViewModel properties, and make an action if there is any update. \n \n

        Go to the code of this fragment and check the responsibility of each component.
    </string>
    <string name="module_3_what_is_data_binding">To avoid boilerplate code, it is possible to directly
        link ViewModel variables with XML of the associated activity / fragment. This is thanks to
        a mechanism called <b>Data Binding</b>. \n
        Data Binding avoids then to the activity (or the fragment) to contain hatch code to link XML
        UI elements and ViewModel. \n \n

        Go to the code and check the difference with the previous screen :
    </string>

    <string name="module_3_pass_arguments_to_view_model">Sometimes, we need to transfer arguments
        from the activity (or fragment) to the ViewModel when it is created. For example, like
        arguments of the previous activity, … \n \n
        Go to the code to check how those arguments are passed to the ViewModel. 
    </string>
    <string name="module_3_previous_counter_value">Value of the previous counter : %1$d</string>

    <string name="module_3_android_mvvm_architecture">The MVVM architecture proposed by Android has
        the following advantages : \n
        - Separation of concerns between UI and business logic; \n
        - Conflict management linked to the activity / fragment lifecycle; \n
        - The ViewModel survives configuration changes (orientation, …); \n
        - Unidirectional communication thanks to LiveData; \n
        - … \n \n

        Check in the code for module 3 classes how is implemented this architecture. \n \n

        If you would like to discover other architecture patterns, go to https://github.com/android/architecture-samples
    </string>


    <string name="next">Next</string>
    <string name="previous">Previous</string>
    <string name="ok">OK</string>
    <string name="done">Done</string>
    <string name="add">Add</string>
    <string name="write_anything">Write anything</string>

    <string name="hello_blank_fragment">Hello blank fragment</string>

    <!-- Module 4 Persistence -->
    <string name="module_4_title">Persistence</string>
    <string name="module_4_two_solutions_title">Two main solutions</string>
    <string name="module_4_description">You often need to persist information locally :
        User preferences, user profile, game high scores, etc.\n
        In this chapter, you will learn two mains solutions to save information locally : <b>Shared Preferences</b> and <b>SQLite</b>.
    </string>
    <string name="module_4_two_solutions">There are several ways to store data locally in order to
        make this data accessible to all application activities.\n\n
        The two mains are :
    </string>

    <!-- Module 4 SharedPreferences -->
    <string name="module_4_shared_preferences">Shared Preferences</string>
    <string name="module_4_shared_preferences_resume">
        - For unstructured data\n- Small amounts
    </string>
    <string name="module_4_shared_preferences_description"> This is a key-value system for primitive types.
        All the values are stored in a single file and you can have a global file for your whole app,
        the <b>Shared Preferences</b>, or a file per activity, the Preferences
        (this one interests us less here).
    </string>
    <string name="module_4_shared_preferences_write"> To <b>write</b> in SharedPreferences, you need to :\n
        1. Get the preference editor \n
        2. Put the primitives (key + value)\n
        3. Commit the edition
    </string>
    <string name="module_4_write_pref_value"> Save preferred value </string>
    <string name="module_4_shared_preferences_read"> To <b>read</b> in SharedPreferences, you need to :\n
        1. Get the preferences \n
        2. Specify the target key + a default value
    </string>
    <string name="module_4_read_pref_value"> Display preferred value </string>
    <string name="module_shared_preferences_test"> Test to save a "preferred value". it will save it in the sharedPreferences.
        You can close the app (or just change the fragment) and when you come back, your "preferred value" will still be there.
    </string>
    <string name="module_4_preferred_value"> Preferred value </string>

    <!-- Module 4 SQLite -->
    <string name="module_4_sqlite">SQLite</string>
    <string name="module_4_room_title">SQLite with Room</string>
    <string name="module_4_sqlite_resume">
        - Large structured data
    </string>
    <string name="module_4_sqlite_description">
        The good news is that to use SQLite in Android, you don\'t need to know SQL.
        You will be using an ORM that will handle the work for you: <b>Room</b>.
    </string>
    <string name="module_4_room_description"> Room has 3 major components:
        <b>Database</b>, which holds all the data,
        <b>Entities</b>, your models, and
        <b>DAOs</b>, helpers to query various tables.\n
        The need to use pure SQL statements is diminished, almost unexisting.
    </string>
    <string name="module_4_room_architecture"> As a good practice, you should expose your data as
        Repositories, 1 Repository for 1 type of Entity, and the ViewModel calls the Repository.
        The ViewModel doesn\'t know how the data is stored, it only knows it’s in the Repository,
        but behind that, the data could be on the network, in a database, in a raw file …
    </string>
    <string name="module_4_lets_test_room"> Now, clic "next" to test Room…</string>
    <string name="module_4_go_to_view_model"> Go to view model</string>


    <!-- Module 5 : Async and Retrofit -->
    <string name="module_5_title">Async &amp; API</string>
    <string name="module_5_description">Asynchronism is current in an Android application : Every big
        action such as saving data in a Room database or querying a web service needs to be done
        in a dedicated thread, in an async way. \n
        In this chapter, you will learn more about the <b>asynchronism</b> and how to query web services with
        a library called <b>Retrofit</b>.
    </string>

    <string name="module_5_async_title">Asynchronism</string>
    <string name="module_5_connect_to_server_title">Connect to a server</string>
    <string name="module_5_retrofit_title">Retrofit</string>
    <string name="module_5_kotlin_co_routines_title">Optional : Kotlin Co-routines</string>

    <string name="module_5_what_is_async">As every program, an Android application has its <b>Main Thread</b>.
        It\'s the thread \"communicating\" with the user, handling interactions with him, … So if it\'s stuck,
        the UI freezes. That\'s why operations on the main thread must be as light as possible. \n \n

        In Android, everything in lifecycle callbacks (onCreate, onResume, …) is executed on the Main Thread.
        Automatically, if Android detects that you are making a \"heavy\" operation, it will terminate your app
        in order to prevent you to let the user wait. You, then, need to manage those operations on
        another thread, meaning <b>asynchronously</b>. \n \n

        For this, you have different components : \n
        - <b>AsyncTasks</b>; \n
        - Schedulers; (not covered in this course) \n\n

        To see an example of AsyncTask, <b>go to the Module 4</b>. \n \n

        Querying a web service is then, a heavy operation. Let\'s check in the following screens how to
        handle it.
    </string>

    <string name="module_5_connect_to_server_description">The majority of mobile apps needs to access
        a back-end server through internet to get data. \n
        To permit your app to connect to the internet, you need to add the corresponding permission
        into the AndroidManifest.xml : \n \n

        \"android.permission.INTERNET\" \n \n

        Comment this permission to check what is happening to your app when it tries to access internet
        without the necessary rights. \n \n

        Going through internet is necessary for you to request your back-end API. To ease our work, we
        will use a library called <b>Retrofit</b>.
    </string>

    <string name="module_5_retrofit_description"><b>Retrofit</b> is an Open-source library, transforming your
        API (written as a Java Interface) into corresponding HTTP requests. \n
        Retrofit is executing the HTTP requests in a different background thread. Meaning that there
        is no need for you to create an AsyncTask : Retrofit is already taking care of the asynchronism
        for you. \n \n

        To transform your JSON into Java objects (and vice versa), you need to provide a <b>converter</b>
        to Retrofit. You can either use GSON or <b>Moshi</b> which are both valid converters.
    </string>

    <string name="module_5_retrofit_dependencies">Go to your build.gradle and check the different dependencies
        you need to add to use these libraries. 
    </string>

    <string name="module_5_retrofit_implementation">Here is an example of a Retrofit implementation.
        Go to the fragment\'s code and check how is the communication implemented between our backend and
        our mobile app. \n \n
        Also, activate the airplane mode of your phone and launch the request again, to see what happens.
        Then, go to the code to check how this behaviour is implemented.
    </string>

    <string name="module_5_pizza_info">Pizza Information</string>
    <string name="module_5_pizza_name">Name : %1$s</string>
    <string name="module_5_pizza_price">Price : %1$.2f €</string>
    <string name="module_5_pizza_vegetarian">Vegetarian : </string>

    <string name="http_get">GET</string>
    <string name="http_post">POST</string>
    <string name="http_put">PUT</string>
    <string name="http_delete">DELETE</string>

    <string name="http_no_connection">No data : Check your internet connection</string>

    <!-- Errors -->
    <string name="technical_error">An unknown error happened : Try again</string>
    <string name="request_error">An error occurred during your request</string>

    <!-- Module 4 RecyclerView -->
    <string name="module_4_room_before_test">
        Oh wait ! Before testing Room, let me quickly introduce you to the RecyclerView !
    </string>
    <string name="module_4_recycler_view">RecyclerView</string>
    <string name="module_4_recycler_view_description">
        A RecyclerView is a component used to show lists <b>scrollable</b> and <b>Memory-efficient</b>.
        As its name tells it : views are recycled.
    </string>
    <string name="module_4_recycler_view_elements_needed">
        Several elements are needed : \n
        - A <b>container</b> (in the XML Layout)\n
        - An <b>XML item layout</b>, to describe how a single element should look\n
        - A <b>Layout Manager</b>, to describe how all elements should stack\n
        - An <b>Adapter</b>, that manage elements.
    </string>
    <string name="module_4_recycler_view_exemple">
        On the next page, you will see an example of RecyclerView which displays all the users of
        our database. <b>Try to find in the AppExemple code</b> all the elements needed which are presented
        above and the elements needed for Room (Entity, Repository, ViewModel…).\n
        PS : As the database is stored locally, nothing will appear until you add users.
    </string>
    <string name="module_4_add_user">Add user</string>
    <string name="module_4_new_user">You want to add a new user ?</string>
    <string name="module_4_first_name">First Name</string>
    <string name="module_4_last_name">Last Name</string>

    <!-- Image content Description -->
    <string name="glide_logo_url">https://raw.githubusercontent.com/bumptech/glide/master/static/glide_logo.png</string>
    <string name="img_source_mod2_drawables_density" translatable="false">Source :
        https://cdn-images-1.medium.com/max/1600/1*Ii4mMCS3QjKDQOML8y7TqA.png</string>
    <string name="img_source_android_developer" translatable="false">Source : android.developer.com</string>
    <string name="img_source_lisa_trapletti" translatable="false">Lisa Trapletti Creation</string>
    <string name="large_text">
        "Material is the metaphor.\n\n"

        "A material metaphor is the unifying theory of a rationalized space and a system of motion."
        "The material is grounded in tactile reality, inspired by the study of paper and ink, yet "
        "technologically advanced and open to imagination and magic.\n"
        "Surfaces and edges of the material provide visual cues that are grounded in reality. The "
        "use of familiar tactile attributes helps users quickly understand affordances. Yet the "
        "flexibility of the material creates new affordances that supercede those in the physical "
        "world, without breaking the rules of physics.\n"
        "The fundamentals of light, surface, and movement are key to conveying how objects move, "
        "interact, and exist in space and in relation to each other. Realistic lighting shows "
        "seams, divides space, and indicates moving parts.\n\n"

        "Bold, graphic, intentional.\n\n"

        "The foundational elements of print based design typography, grids, space, scale, color, "
        "and use of imagery guide visual treatments. These elements do far more than please the "
        "eye. They create hierarchy, meaning, and focus. Deliberate color choices, edge to edge "
        "imagery, large scale typography, and intentional white space create a bold and graphic "
        "interface that immerse the user in the experience.\n"
        "An emphasis on user actions makes core functionality immediately apparent and provides "
        "waypoints for the user.\n\n"

        "Motion provides meaning.\n\n"

        "Motion respects and reinforces the user as the prime mover. Primary user actions are "
        "inflection points that initiate motion, transforming the whole design.\n"
        "All action takes place in a single environment. Objects are presented to the user without "
        "breaking the continuity of experience even as they transform and reorganize.\n"
        "Motion is meaningful and appropriate, serving to focus attention and maintain continuity. "
        "Feedback is subtle yet clear. Transitions are efﬁcient yet coherent.\n\n"

        "3D world.\n\n"

        "The material environment is a 3D space, which means all objects have x, y, and z "
        "dimensions. The z-axis is perpendicularly aligned to the plane of the display, with the "
        "positive z-axis extending towards the viewer. Every sheet of material occupies a single "
        "position along the z-axis and has a standard 1dp thickness.\n"
        "On the web, the z-axis is used for layering and not for perspective. The 3D world is "
        "emulated by manipulating the y-axis.\n\n"

        "Light and shadow.\n\n"

        "Within the material environment, virtual lights illuminate the scene. Key lights create "
        "directional shadows, while ambient light creates soft shadows from all angles.\n"
        "Shadows in the material environment are cast by these two light sources. In Android "
        "development, shadows occur when light sources are blocked by sheets of material at "
        "various positions along the z-axis. On the web, shadows are depicted by manipulating the "
        "y-axis only. The following example shows the card with a height of 6dp.\n\n"

        "Resting elevation.\n\n"

        "All material objects, regardless of size, have a resting elevation, or default elevation "
        "that does not change. If an object changes elevation, it should return to its resting "
        "elevation as soon as possible.\n\n"

        "Component elevations.\n\n"

        "The resting elevation for a component type is consistent across apps (e.g., FAB elevation "
        "does not vary from 6dp in one app to 16dp in another app).\n"
        "Components may have different resting elevations across platforms, depending on the depth "
        "of the environment (e.g., TV has a greater depth than mobile or desktop).\n\n"

        "Responsive elevation and dynamic elevation offsets.\n\n"

        "Some component types have responsive elevation, meaning they change elevation in response "
        "to user input (e.g., normal, focused, and pressed) or system events. These elevation "
        "changes are consistently implemented using dynamic elevation offsets.\n"
        "Dynamic elevation offsets are the goal elevation that a component moves towards, relative "
        "to the component’s resting state. They ensure that elevation changes are consistent "
        "across actions and component types. For example, all components that lift on press have "
        "the same elevation change relative to their resting elevation.\n"
        "Once the input event is completed or cancelled, the component will return to its resting "
        "elevation.\n\n"

        "Avoiding elevation interference.\n\n"

        "Components with responsive elevations may encounter other components as they move between "
        "their resting elevations and dynamic elevation offsets. Because material cannot pass "
        "through other material, components avoid interfering with one another any number of ways, "
        "whether on a per component basis or using the entire app layout.\n"
        "On a component level, components can move or be removed before they cause interference. "
        "For example, a floating action button (FAB) can disappear or move off screen before a "
        "user picks up a card, or it can move if a snackbar appears.\n"
        "On the layout level, design your app layout to minimize opportunities for interference. "
        "For example, position the FAB to one side of stream of a cards so the FAB won’t interfere "
        "when a user tries to pick up one of cards.\n\n"
    </string>

    <!-- Module 6 : Kotlin -->
    <string name="module_6_title">Kotlin</string>
    <string name="module_6_description">Since some years now, Google decided to choose <b>Kotlin</b> as its
        preferred language to develop Android apps. That\'s why being able to understand Kotlin is
        important in the mobile development world. \n
        In this module, you will have a a look at Kotlin and its main differences with Java, but also
        some useful links to help you to learn this new language.
    </string>

    <string name="module_6_what_is_kotlin_title">What is Kotlin ?</string>
    <string name="module_6_what_is_kotlin_description">Kotlin is the preferred programming language of Google
        to develop Android apps. It has been developed by JetBrains and is described by its creators
        as <i>\"a modern programming language that makes developers happier\"</i>. \n
        The main inspiration to create the Kotlin language is <b>Scala</b> , a programming language
        more focus on the functional development. However, Kotlin goal was to group all the best features
        of every existing language. \n \n \n

        <b><u>What are the strengths of Kotlin ?</u></b> \n \n

        - Kotlin is <b>concise</b> : It drastically reduces boilerplate code such as getters, setters,
        and many other elements, making your code more concise but still very light and readable.
        That is really helping to look over the code in a faster and easier way but also to maintain
        less amount of code. \n \n

        - Kotlin is <b>safe</b> : The language tries to avoid as much errors as possible, \"just\" by
        its syntax. It\'s for example the case with NullPointerExceptions, that Kotlin tries to reduce
        as much as possible by bringing the <i>Nullable</i> field management. However, Kotlin is not
        making everything by itself : Developers should not forget that they need to \"play the game\" ;-) \n \n

        - Kotlin is <b>interoperable</b> : It is designed to work perfectly with the Java language, as you
        can see in the <i>KotlinPresentationFragment</i>. This is a really big advantage : You can slowly
        migrate a project to Kotlin, without putting all your Java classes to the garbage. Android
        Studio also incorporated a plugin to directly convert your Java code to Kotlin and vice-versa.
        Too cool, isn\'t it ?
    </string>
    <string name="module_6_kotlin_example_title">Kotlin Example</string>
    <string name="module_6_kotlin_example_description">In this screen, we will re-implement the Retrofit
        Example, but using the Kotlin language, so that you can have an example of main differences between
        Java and Kotlin. \n
        Basically, Android features are the same (View Binding, Data Binding, …) but the language
        syntax is different. Go to the code of this fragment to check that.
    </string>
    <string name="module_6_kotlin_links_title">Useful links</string>
    <string name="module_6_kotlin_links_description">It exists plenty of interesting resources to learn more
        about the Kotlin language. \n
        In the useful links, we can find : \n  \n

        - The official Kotlin documentation : https://kotlinlang.org/docs/reference/basic-syntax.html \n
        - The online console : https://play.kotlinlang.org/ \n
        - Udacity tutorial to learn Kotlin : https://classroom.udacity.com/courses/ud9011 \n
        - Openclassrooms tutorial : https://openclassrooms.com/fr/courses/5353106-initiez-vous-a-kotlin \n \n \n


        Enjoy your journey in the Kotlin sphere ! :-)
    </string>
</resources>
